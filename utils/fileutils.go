package utils

import (
	"encoding/csv"
	"io"
	"net/http"
	"os"
)

// used as helper method for OpenFile
func downloadFile(url string) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	// keep in default tmp folder with just random number as name
	// because we'll just be deleting this soon anyways
	out, err := os.CreateTemp("", "")
	if err != nil {
		return "", err
	}
	defer out.Close()

	// save file name to access later
	tmpFilename := out.Name()
	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return "", err
	}

	return tmpFilename, nil
}

func WriteToCSV(filename string, records [][]string) error {
	// 660 is rw for user and groups
	// not a temp dir because user actually wants results
	err := os.Mkdir("output", 660)
	if err != nil && !os.IsExist(err) {
		return err
	}

	// truncates existing files by default
	f, err := os.Create("output/" + filename)
	if err != nil {
		return err
	}
	defer f.Close()

	w := csv.NewWriter(f)
	defer w.Flush()

	headers := []string{"word", "count"}
	w.Write(headers)

	for _, record := range records {
		w.Write(record)
	}

	return err
}

// checks if url or local file and opens it accordingly
func OpenFile(p string) (*os.File, error) {
	if IsValidFile(p) {
		f, err := os.Open(p)
		return f, err
	} else if IsValidURL(p) {
		tmpFilename, err := downloadFile(p)
		if err != nil {
			return nil, err
		}
		f, err := os.Open(tmpFilename)
		return f, err
	}
	return nil, nil
}

func GetFilename(p string) string {
	// returns filename without extension
	if IsValidFile(p) {
		return FilepathToFilename(p)
	} else if IsValidURL(p) {
		return UrlToFilename(p)
	}
	return ""
}

// so we can reuse the teardown code in tests and main
func CleanupOutputData() {
	// remove all csvs generated by program
	err := os.RemoveAll("output")
	if err != nil {
		// log error
	}
}
